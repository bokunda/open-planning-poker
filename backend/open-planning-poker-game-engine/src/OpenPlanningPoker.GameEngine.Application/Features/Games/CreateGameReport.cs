using OpenPlanningPoker.Shared.Services;

namespace OpenPlanningPoker.GameEngine.Application.Features.Games;

public sealed record CreateGameReportResponse(string GameName, MemoryStream Stream);

public sealed record CreateGameReportCommand(Guid GameId) : IRequest<Result<CreateGameReportResponse, ApplicationError>>;

public static class CreateGameReport
{
    public sealed class RequestHandler(
        IGameRepository gameRepository,
        ITicketRepository ticketRepository,
        IVoteRepository voteRepository,
        IUserService userService)
        : IRequestHandler<CreateGameReportCommand, Result<CreateGameReportResponse, ApplicationError>>
    {
        public async Task<Result<CreateGameReportResponse, ApplicationError>> Handle(CreateGameReportCommand request, CancellationToken cancellationToken = default)
        {
            // TODO: Enhance this to use one query
            var game = await GetGameData(request.GameId, cancellationToken);
            var usernames = await GetUsernames(game, cancellationToken);

            using var memoryStream = new MemoryStream();
            Document.Create(container =>
            {
                container.Page(page =>
                {
                    page.Size(PageSizes.A4);
                    page.Margin(16, QuestPDF.Infrastructure.Unit.Millimetre);
                    page.Header()
                        .PaddingBottom(8, QuestPDF.Infrastructure.Unit.Millimetre)
                        .Column(column =>
                        {
                            column.Item().Text("Game Report").FontSize(20).Bold();
                            column.Item()
                                .PaddingTop(6, QuestPDF.Infrastructure.Unit.Point)
                                .Text($"Id: {game!.Id}");
                            column.Item().Text($"Name: {game.Name}");
                            column.Item().Text($"Created On: {game.CreatedOn}");
                            column.Item().Text($"Total Tickets: {game.Tickets!.Count}");
                            column.Item().Text($"Average Ticket Estimation: {GetAverageVote(game.Tickets.SelectMany(ticket => ticket.Votes ?? Enumerable.Empty<Vote>()))}");
                        });

                    page.Content()
                        .PaddingBottom(16, QuestPDF.Infrastructure.Unit.Millimetre)
                        .Column(column =>
                        {
                            column.Spacing(4, QuestPDF.Infrastructure.Unit.Point);

                            foreach (var ticket in game!.Tickets!)
                            {
                                column.Item()
                                    .PaddingTop(6, QuestPDF.Infrastructure.Unit.Point)
                                    .PaddingBottom(6, QuestPDF.Infrastructure.Unit.Point)
                                    .Text($"Ticket: {ticket.Name} (avg. {GetAverageVote(ticket.Votes ?? Enumerable.Empty<Vote>())})")
                                    .FontSize(16)
                                    .Bold();

                                if (ticket.Votes is null || ticket.Votes.Count == 0)
                                {
                                    column.Item()
                                        .PaddingLeft(16, QuestPDF.Infrastructure.Unit.Point)
                                        .Text("No votes yet")
                                        .FontSize(14);
                                    continue;
                                }

                                foreach (var vote in ticket.Votes!)
                                {
                                    column.Item()
                                        .PaddingLeft(16, QuestPDF.Infrastructure.Unit.Point)
                                        .Text($"Vote: {vote.Value} by {usernames[vote.PlayerId]}")
                                        .FontSize(14);
                                }
                            }
                        });

                    page.Footer()
                        .AlignCenter()
                        .Text($"Generated by Open Planning Poker - {DateTime.UtcNow} UTC");
                });
            })
            .GeneratePdf(memoryStream);

            return new CreateGameReportResponse(game!.Name, memoryStream);
        }

        private async Task<Dictionary<Guid, string>> GetUsernames(Game? game, CancellationToken cancellationToken)
        {
            var playerIds = game?.Tickets?
                .SelectMany(ticket => ticket.Votes ?? Enumerable.Empty<Vote>())
                .Select(vote => vote.PlayerId)
                .Distinct()
                .ToList();

            var usernames = new Dictionary<Guid, string>();
            foreach (var playerId in playerIds ?? Enumerable.Empty<Guid>())
            {
                var username = (await userService.GetAsync($"{playerId}", cancellationToken))?.UserName ?? "Expired";
                usernames.Add(playerId, username);
            }

            return usernames;
        }

        private async Task<Game?> GetGameData(Guid gameId, CancellationToken cancellationToken)
        {
            var game = await gameRepository.GetByIdAsync(gameId, cancellationToken);
            var tickets = await ticketRepository.GetByGame(gameId, cancellationToken);
            var votes = await voteRepository.GetByGame(gameId, null, cancellationToken);

            if (game is null || tickets is null || votes is null)
            {
                throw new Exception($"Game data is corrupted, gameId: {gameId}.");
            }

            foreach (var ticket in tickets)
            {
                ticket.Votes = [.. votes.Where(vote => vote.TicketId == ticket.Id)];
            }
            game.Tickets = [.. tickets];
            return game;
        }
    
        private static double GetAverageVote(IEnumerable<Vote> votes)
        {
            var validVotes = votes
                .Select(vote => double.TryParse(vote.Value, out var value) ? value : (double?)null)
                .Where(value => value.HasValue)
                .Select(value => value!.Value);

            return validVotes.Any() ? validVotes.Average() : 0;
        }
    }
}